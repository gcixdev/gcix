{"config":{"lang":["en","de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"gcix - Write your GitLab CI pipelines in X languages","text":"<p>The complete documentation is found at https://gcix.gitlab.com/gcix/</p> <p>The GitLab CI X Library (gcix) is a library to create dynamic pipelines for GitLab CI.</p> <p>With the gcix you can write your GitLab CI pipelines in multiple languages.</p>"},{"location":"#supported-languages","title":"Supported languages","text":"<ul> <li>Typescript/JavaScript (native)</li> <li>Python</li> </ul> <p>A simple pipeline could look like...</p> <p>...this in Typescript</p> <pre><code>import { Pipeline, Job } from \"gcix\"\nconst pipeline = new Pipeline()\nconst job = new Job({stage: \"build\", scripts: [\"docker build .\"]})\npipeline.addChildren({jobsOrJobCollections: [job]})\npipeline.writeYaml()\n</code></pre> <p>...this in Python</p> <pre><code>from gcip import Pipeline, Job\npipeline = Pipeline()\njob      = Job(stage=\"build\", scripts=[\"docker build .\"])\npipeline.add_children(jobs_or_job_collections=[job])\npipeline.write_yaml()\n</code></pre>"},{"location":"#intro","title":"Intro","text":"<p>The gcix is a rewrite of the gcip, the reason behind the rewrite is, that I wanted to learn Typescript, and give developers the choice to use the language they are familiar with. This is because I chose Typescript and a tool called jsii made by AWS. jsii translates the different language API's to typescript. The user which uses Python is using Pythons syntax, behind the scenes they are getting translated to Typescript.</p>"},{"location":"#examples","title":"Examples","text":"<p>For a more complex and real world example, just check out our projects .gitlab-ci.ts. The .gitlab-ci.ts is the written example of a working gcix in Typescript. The Typescript code is getting rendered and stored as an artifact in the pipeline see generated yaml file.</p> <p>The gcix is using the GitLab feature of dynamic child pipelines. First the <code>.gitlab-ci.ts</code> generates the common GitLab CI yaml file which is then started as child pipeline. To get the generated pipeline it is necessary to invoke the <code>.gitlab-ci.ts</code> with <code>ts-node</code>. To get an idea of a dynamic child pipelines setup, you can have a look into .gitlab-ci.yml.</p> <p>Creating your pipelines in any supported programming language code allows you all the features of that language, like:</p> <ul> <li>re-use code (DRY - Don't repeat yourself)</li> <li>use variables, control flow (if-then-else, loops, ...), complex data structures, input/output, error handling, ...</li> <li>programming paradigms like object-oriented or functional programming</li> <li>use 3rd party libraries in your pipelines</li> <li>test driven development of pipelines with Jest(Typescript), pytest(Python)...</li> <li>package management and distribution of your pipeline code</li> <li>... anything you can imagine to do with Python code</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Please read the User Documentation to get a quick introduction into most features of the gcix.</p> <p>You can consult the API Reference to get an overview of all classes and methods and a deeper view into their parameters.</p> <p>For more information on how to create your own library based on gcix, please read the Developer Documentation to learn about good practices and conventions.</p>"},{"location":"#why-pipelines-as-code","title":"Why pipelines as code?","text":"<p>There has been a really good discussion on Hacker News about configuration vs code. Comments stating that when struggling around with the limitations of static configuration we start writing pipelines as code, until we hassle around with complex code and start re-writing complex pipelines in static configuration and so forth.</p> <p>It is absolutely right that pipelines as code are not new and have lots of drawbacks. Chances are good that you have the one guru in you company loving this project and is writing weird pipelines that nobody else understands. Also comments state that pipelines are those basic things that build and test your code and shouldn't be in code too, because then you might have a pipeline that build and test your pipeline code.</p> <p>All those statements are quite true. However all those statements could be applied to static configuration. We started this project because of GitLab CI yaml files growing over thousands of lines. We tried to implement some logic with clunky rule sets. We tried to re-use code with yaml templates. We tried to write predefined pipelines by using includes. We started to write bash scripts that do bulk loads of work within a job. All in all those felt like a bad workaround, while having in mind how much cleaner this might be, writing our pipelines in code. That is why we started this project and since using it with great success.</p> <p>However it is absolutely important to understand the gcix as a supplement and not as a substitution to GitLab CI yaml files. As long you are fine with having a couple of jobs you could easily describe in static configuration, just do it. If you feel that you can't manage the complexity of you static yaml configuration and started to build lots of helper scripts, you could consider writing your pipelines in code. This considerations should include, if the pipeline code you write is definitely an advantage over the static scripts you had before - and not just for you but also for your colleagues and the company you are writing the code for.</p> <p>The gcix should be a choice - not a standard.</p>"},{"location":"#thanks","title":"Thanks","text":"<p>First of all, I have to thank Thomas Steinbach he created the GitLab CI Python Library (gcip) and started a great journey with GitLab CI pipelines as code. Another thank you goes to the DB Systel GmbH.</p>"},{"location":"#author","title":"Author","text":"<p>gcix was created by Daniel von E\u00dfen in 2023.</p>"},{"location":"#license","title":"License","text":"<p>The content of this repository is licensed under the Apache 2.0 license.</p> <p>Copyright Daniel von E\u00dfen</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>User Documentation</li> <li>Developer Documentation</li> <li>API Reference</li> <li>Typescript</li> <li>Python</li> </ul>"},{"location":"dev/contribution/CODE_OF_CONDUCT/","title":"gcix Project Code of Conduct","text":"<p>We, the community behind the gcix project, are committed to providing a safe, respectful, and inclusive environment for all participants. This Code of Conduct outlines our expectations for behavior within our community, both online and offline, and applies to all contributors, maintainers, users, and participants.</p>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#expected-behavior","title":"Expected Behavior","text":"<ul> <li>Treat all individuals with respect, kindness, and empathy.</li> <li>Be considerate of differing opinions, experiences, and backgrounds.</li> <li>Communicate openly, professionally, and constructively.</li> <li>Use welcoming and inclusive language in all interactions.</li> </ul>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#unacceptable-behavior","title":"Unacceptable Behavior","text":"<p>The following behaviors are considered unacceptable and will not be tolerated within our community:</p> <ul> <li>Harassment, bullying, discrimination, or offensive comments related to race, gender, sexual orientation, religion, disability, or any other personal characteristic.</li> <li>Intimidation, threats, or unwelcome advances of any kind.</li> <li>Disruptive or disrespectful comments, trolling, or personal attacks.</li> <li>Sharing or promoting explicit or offensive content.</li> <li>Any behavior that creates an uncomfortable or unsafe environment for others.</li> </ul>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#reporting-guidelines","title":"Reporting Guidelines","text":"<p>If you experience or witness behavior that violates this Code of Conduct, please follow these steps:</p> <ol> <li>Notify the individual that their behavior is inappropriate and ask them to stop.</li> <li>If the behavior continues or you are uncomfortable addressing it directly, report the incident to the project maintainers at gcix@vonessen.eu.</li> <li>Provide details of the incident, including date, time, individuals involved, and a description of what occurred.</li> </ol>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#consequences","title":"Consequences","text":"<p>Unacceptable behavior will not be tolerated within our community. Consequences for violating this Code of Conduct may include:</p> <ul> <li>Verbal or written warnings.</li> <li>Temporary or permanent bans from community interactions, events, or online platforms.</li> </ul>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>The project maintainers are responsible for enforcing this Code of Conduct. They will review and investigate all reported incidents promptly, treating all reports with discretion and confidentiality.</p>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies to all community spaces associated with the gcix project, including but not limited to:</p> <ul> <li>GitLab repositories, issues, and discussions.</li> <li>Online forums, chat rooms, and mailing lists.</li> <li>Project-related events and meetups.</li> </ul>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#modifications-and-updates","title":"Modifications and Updates","text":"<p>This Code of Conduct may be updated or modified from time to time. Contributors and participants will be informed of any changes, and it is their responsibility to review and adhere to the most recent version.</p>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#contact-information","title":"Contact Information","text":"<p>If you have any questions, concerns, or need to report an incident, please contact the project maintainers at [email address].</p>"},{"location":"dev/contribution/CODE_OF_CONDUCT/#license","title":"License","text":"<p>This Code of Conduct is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.</p> <p>We value your participation and contribution to the gcix project. Let's work together to create a welcoming and inclusive community for everyone.</p>"},{"location":"dev/contribution/CONTRIBUTING/","title":"Contributing to the gcix","text":"<p>Thank you for considering contributing to the gcix! This document outlines the guidelines for contributing to our project. By participating, you agree to abide by these guidelines.</p>"},{"location":"dev/contribution/CONTRIBUTING/#how-can-i-contribute","title":"How Can I Contribute?","text":""},{"location":"dev/contribution/CONTRIBUTING/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug in the project, please create an issue on our issue tracker with a clear description of the bug. Include relevant details such as the steps to reproduce and the expected vs. actual behavior.</p>"},{"location":"dev/contribution/CONTRIBUTING/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>To suggest an enhancement, create an issue on our issue tracker with a clear description of your proposed improvement. We welcome new ideas and feedback!</p>"},{"location":"dev/contribution/CONTRIBUTING/#code-contributions","title":"Code Contributions","text":"<p>We welcome code contributions to improve the gcix. Please follow the Coding Guidelines below.</p>"},{"location":"dev/contribution/CONTRIBUTING/#documentation","title":"Documentation","text":"<p>Help improve our documentation by fixing typos, adding examples, or clarifying explanations. If you notice anything that needs improvement, submit a pull request.</p>"},{"location":"dev/contribution/CONTRIBUTING/#testing","title":"Testing","text":"<p>Help us improve the project's quality by writing and running tests. If you're adding new features or fixing bugs, consider adding relevant tests.</p>"},{"location":"dev/contribution/CONTRIBUTING/#getting-started","title":"Getting Started","text":"<p>To get started contributing to the gcix, follow these steps:</p>"},{"location":"dev/contribution/CONTRIBUTING/#fork-the-repository","title":"Fork the Repository","text":"<p>Fork the gcix to your GitLab account by clicking the \"Fork\" button.</p>"},{"location":"dev/contribution/CONTRIBUTING/#install-dependencies","title":"Install Dependencies","text":"<p>Navigate to the project directory and install dependencies:</p> <ul> <li>You need to have NodeJS already installed.</li> <li>Ensure you have <code>npx</code> installed.</li> </ul> <pre><code>cd your-forked-repo\n# This will install and execute projen\nnpx projen\n</code></pre>"},{"location":"dev/contribution/CONTRIBUTING/#make-changes","title":"Make Changes","text":"<p>Make your changes and improvements in your local repository.</p>"},{"location":"dev/contribution/CONTRIBUTING/#run-tests","title":"Run Tests","text":"<p>Run tests to ensure your changes haven't broken anything:</p> <pre><code>npx projen test:update # ensures that the comparison files are updated\n</code></pre>"},{"location":"dev/contribution/CONTRIBUTING/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Write clear, concise, and well-documented code.</li> <li>Write unit tests for your code.</li> </ul>"},{"location":"dev/contribution/CONTRIBUTING/#commit-guidelines","title":"Commit Guidelines","text":"<ul> <li>Commit messages should be descriptive and follow the conventional commit format. See Conventional Commits.</li> </ul>"},{"location":"dev/contribution/CONTRIBUTING/#merge-requests","title":"Merge Requests","text":"<p>When you're ready to submit your changes, follow these steps:</p> <ol> <li>Push your changes to your forked repository.</li> <li>Create a pull request against the main repository's <code>main</code> branch.</li> <li>Provide a clear title and description for your pull request, referencing any relevant issues.</li> <li>A project maintainer will review your pull request and provide feedback.</li> </ol>"},{"location":"dev/contribution/CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":"<p>Please review and adhere to our Code of Conduct while participating in this project.</p>"},{"location":"dev/contribution/CONTRIBUTING/#license","title":"License","text":"<p>By contributing to the gcix, you agree that your contributions will be licensed under the Apache License 2.0.</p> <p>Thank you for contributing to the gcix!</p>"},{"location":"dev/contribution/LICENSE/","title":"Apache License 2.0","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>\u00a9 You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"user/01-core/","title":"Core","text":"<p>The gcix is a Typescript library designed to facilitate the creation of dynamic pipelines for GitLab CI.</p> <p>Additionally, it provides examples in both Typescript and Python.</p> <p>Please select the language in which you want to see the examples.</p> TypescriptPython"},{"location":"user/01-core/#configuring-your-project-to-use-gcix","title":"Configuring your project to use gcix","text":"<p>Your GitLab project requires the following two files:</p> <pre><code>MyProject\n\u251c .gitlab-ci.(ts|py)\n\u2514 .gitlab-ci.yml\n</code></pre> <p>The .gitlab-ci.yml file is the one you are familiar with, responsible for rendering and triggering the child pipeline created with gcix. The latter is written into the .gitlab-ci.ts file.</p> <p>Now, let's examine how the .gitlab-ci.yml file should be structured for this project:</p> <pre><code>---\ngenerate-pipeline:\nstage: build\nimage: node:18\nscript:\n- npx projen install:ci\n- npx ts-node .gitlab-ci.ts\nartifacts:\npaths:\n- generated-config.yml\ntags:\n- gcix\nrun-pipeline:\nstage: deploy\nneeds:\n- generate-pipeline\ntrigger:\ninclude:\n- artifact: generated-config.yml\njob: generate-pipeline\nstrategy: depend\n</code></pre> <p>The pipeline code for gcix is written in the file named .gitlab-ci.ts. The upcoming sections demonstrate how to create this pipeline code.</p> <p>Alternatively, instead of installing gcix in a Node container, you have the option to utilize the official Docker image that is released for each tag.</p> <p>In this case, the initial job would appear as follows:</p> <pre><code>generate-pipeline:\nstage: build\nimage: gcix/gcix:1.0.0\nscript: /usr/src/app/docker/gcip.sh\nartifacts:\npaths:\n- generated-config.yml\n</code></pre>"},{"location":"user/01-core/#hints-regarding-the-following-examples","title":"Hints regarding the following examples","text":"<p>All the code examples in the upcoming chapters are designed to be compatible with [Jest][1] or [pytest][2].</p> <p>As an example, a code snippet could be as follows:</p> TypescriptPython <pre><code>import gcix\nimport { check } from \"../../comparison\"\ntest(\"test\", () =&gt; {\nconst pipeline = new gcix.Pipeline()\npipeline.addChildren({\njob_or_job_collections: [\nnew gcix.Job({\nstage: \"print_date\",\nscript: \"date\"\n}\n)]\n});\ncheck(pipeline.render(), expect)\n});\n</code></pre> <p>To transform this Jest test into a valid <code>.gitlab-ci.ts</code> file, you need to:</p> <ul> <li>Remove the import statement: <code>import { check } from \"../../comparison\"</code>.</li> <li>Place your pipeline code directly in the <code>gitlab-ci.ts</code>, outside the <code>test(\"test\", () =&gt; {})</code> function.</li> <li>Instead of testing the rendered pipeline with <code>check(pipeline.render(), expect)</code>, you should write the <code>generated-pipeline.yml</code> with <code>pipeline.writeYaml()</code>.</li> </ul> <p>The resulting <code>.gitlab-ci.ts</code> code derived from the example would look like the following:</p> <pre><code>import gcip\nfrom tests import conftest\ndef test():\npipeline = gcip.Pipeline()\npipeline.add_children(jobs_or_job_collections: [gcip.Job(stage=\"print_date\", script=\"date\")])\nconftest.check(pipeline.render())\n</code></pre> <p>To transform this [Pytest][2] code into a valid <code>.gitlab-ci.oy</code> file, you need to:</p> <ul> <li>Remove the import statement: <code>from tests import conftest</code>..</li> <li>Place your pipeline code directly in the <code>gitlab-ci.py</code>, outside the <code>def test():</code> function.</li> <li>Instead of testing the rendered pipeline with <code>conftest.check(pipeline.render())</code>, you should write the <code>generated-pipeline.yml</code> with <code>pipeline.write_yaml()</code>.</li> </ul> <p>The resulting <code>.gitlab-ci.(ts|py)</code> file, derived from the example, would look like the following:</p> TypescriptPython <pre><code>import gcix\npipeline = new gcix.Pipeline()\npipeline.addChildren({\njobsOrJobCollections: [\nnew gcix.Job(stage=\"print_date\", script=\"date\")\n]\n});\npipeline.writeYaml()\n</code></pre> <pre><code>import gcix\npipeline = gcix.Pipeline()\npipeline.add_children(jobs_or_job_collection=[gcix.Job(stage=\"print_date\", script=\"date\")])\npipeline.write_yaml()\n</code></pre>"},{"location":"user/01-core/#create-a-pipeline-with-one-job","title":"Create a pipeline with one job","text":"<p>Input:</p> TypescriptPython <p><pre><code>import { Pipeline, Job } from \"../../../src\";\nimport { check } from \"../../comparison\";\ntest(\"test\", () =&gt; {\nconst pipeline = new Pipeline();\npipeline.addChildren({\njobsOrJobCollections: [new Job({ stage: \"print_date\", scripts: [\"date\"] })],\n});\ncheck(pipeline.render(), expect);\n});\n</code></pre> Keep in mind that, as mentioned in the Hints regarding the following examples, your pipeline code should conclude with <code>pipeline.writeYaml()</code>.</p> <p><pre><code>import gcip\nfrom tests import conftest\ndef test():\npipeline = gcip.Pipeline()\npipeline.add_children(gcip.Job(stage=\"print_date\", script=\"date\"))\nconftest.check(pipeline.render())\n</code></pre> Keep in mind that, as mentioned in the Hints regarding the following examples, your pipeline code should conclude with <code>pipeline.write_yaml()</code>.</p> <p>Output:</p> <pre><code>stages:\n- print_date\nprint-date:\nstage: print_date\nscript:\n- date\n</code></pre>"},{"location":"user/01-core/#configure-jobs","title":"Configure jobs","text":"<p>To configure jobs, you can utilize the following methods:</p> <p>Input:</p> TypescriptPython <pre><code>import * as gcix from \"../../../src\";\nimport { check } from \"../../comparison\";\ntest(\"test\", () =&gt; {\nconst pipeline = new gcix.Pipeline();\nconst job = new gcix.Job({ stage: \"print_date\", scripts: [\"date\"] });\njob.assignImage(\"docker/image:example\");\njob.prependScripts([\"./before-script.sh\"]);\njob.appendScripts([\"./after-script.sh\"]);\njob.addVariables({ USER: \"Max Power\", URL: \"https://example.com\" });\njob.addTags([\"test\", \"europe\"]);\njob.assignArtifacts(new gcix.Artifacts({ paths: [\"binaries/\", \".config\"] }));\njob.appendRules([new gcix.Rule({ ifStatement: \"$MY_VARIABLE_IS_PRESENT\" })]);\npipeline.addChildren({ jobsOrJobCollections: [job] });\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef test():\npipeline = gcip.Pipeline()\njob = gcip.Job(stage=\"print_date\", script=\"date\")\njob.set_image(\"docker/image:example\")\njob.prepend_scripts(\"./before-script.sh\")\njob.append_scripts(\"./after-script.sh\")\njob.add_variables(USER=\"Max Power\", URL=\"https://example.com\")\njob.add_tags(\"test\", \"europe\")\njob.artifacts.add_paths(\"binaries/\", \".config\")\njob.append_rules(gcip.Rule(if_statement=\"$MY_VARIABLE_IS_PRESENT\"))\npipeline.add_children(job)\nconftest.check(pipeline.render())\n</code></pre> <p>Output:</p> <pre><code>stages:\n- print_date\nprint-date:\nimage:\nname: docker/image:example\nstage: print_date\nscript:\n- ./before-script.sh\n- date\n- ./after-script.sh\nvariables:\nUSER: Max Power\nURL: https://example.com\nrules:\n- if: $MY_VARIABLE_IS_PRESENT\nwhen: on_success\nallow_failure: false\nartifacts:\nname: ci_job_name-my-awsome-feature-branch\npaths:\n- binaries/\n- .config\ntags:\n- test\n- europe\n</code></pre>"},{"location":"user/01-core/#bundling-jobs-as-collections","title":"Bundling jobs as collections","text":"<p>The class <code>JobCollection</code> allows you to group jobs together to apply a common configuration to all included jobs. This collection shares the same configuration methods as demonstrated in the previous example for individual jobs.</p> <p>Input:</p> TypescriptPython <p><pre><code>import * as gcix from \"../../../src\";\nimport { check } from \"../../comparison\";\ntest(\"test\", () =&gt; {\nconst collection = new gcix.JobCollection();\nconst job1 = new gcix.Job({ stage: \"job1\", scripts: [\"script1.sh\"] });\njob1.prependScripts([\"from-job-1.sh\"]);\ncollection.addChildren({\njobsOrJobCollections: [\njob1,\nnew gcix.Job({ stage: \"job2\", scripts: [\"script2.sh\"] }),\n],\n});\ncollection.prependScripts([\"from-sequence.sh\"]);\nconst pipeline = new gcix.Pipeline();\npipeline.addChildren({ jobsOrJobCollections: [collection] });\ncheck(pipeline.render(), expect);\n});\n</code></pre> As evident from the output, jobs can have their own configurations (indicated by <code>job1.prependScripts([...])</code>), and they can also inherit common configurations from their collection (indicated by <code>collection.prependScripts([...])</code>).</p> <pre><code>import gcip\nfrom tests import conftest\ndef test():\nsequence = gcip.Sequence()\njob1 = gcip.Job(stage=\"job1\", script=\"script1.sh\")\njob1.prepend_scripts(\"from-job-1.sh\")\nsequence.add_children(\njob1,\ngcip.Job(stage=\"job2\", script=\"script2.sh\"),\n)\nsequence.prepend_scripts(\"from-sequence.sh\")\npipeline = gcip.Pipeline()\npipeline.add_children(sequence)\nconftest.check(pipeline.render())\n</code></pre> <p>As evident from the output, jobs can have their own configurations (indicated by <code>job1.prepend_scripts([...])</code>), and they can also inherit common configurations from their collection (indicated by <code>collection.prepend_scripts([...])</code>).</p> <p>Output:</p> <pre><code>stages:\n- job1\n- job2\njob1:\nstage: job1\nscript:\n- from-sequence.sh\n- from-job-1.sh\n- script1.sh\njob2:\nstage: job2\nscript:\n- from-sequence.sh\n- script2.sh\n</code></pre>"},{"location":"user/01-core/#stacking-collections","title":"Stacking collections","text":"<p>Input:</p> TypescriptPython <pre><code>import { Pipeline, Job, JobCollection } from \"../../../src\";\nimport { check } from \"../../comparison\";\ntest(\"test\", () =&gt; {\nconst collectionA = new JobCollection();\ncollectionA.addChildren({\njobsOrJobCollections: [new Job({ stage: \"job1\", scripts: [\"script1.sh\"] })],\n});\ncollectionA.prependScripts([\"from-sequence-a.sh\"]);\nconst collectionB = new JobCollection();\ncollectionB.addChildren({ jobsOrJobCollections: [collectionA] });\ncollectionB.addChildren({\njobsOrJobCollections: [new Job({ stage: \"job2\", scripts: [\"script2.sh\"] })],\n});\ncollectionB.prependScripts([\"from-sequence-b.sh\"]);\nconst pipeline = new Pipeline();\npipeline.addChildren({ jobsOrJobCollections: [collectionB] });\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef test():\nsequence_a = gcip.Sequence()\nsequence_a.add_children(gcip.Job(stage=\"job1\", script=\"script1.sh\"))\nsequence_a.prepend_scripts(\"from-sequence-a.sh\")\nsequence_b = gcip.Sequence()\nsequence_b.add_children(sequence_a)\nsequence_b.add_children(gcip.Job(stage=\"job2\", script=\"script2.sh\"))\nsequence_b.prepend_scripts(\"from-sequence-b.sh\")\npipeline = gcip.Pipeline()\npipeline.add_children(sequence_b)\nconftest.check(pipeline.render())\n</code></pre> <p>Output:</p> <pre><code>stages:\n- job1\n- job2\njob1:\nstage: job1\nscript:\n- from-sequence-b.sh\n- from-sequence-a.sh\n- script1.sh\njob2:\nstage: job2\nscript:\n- from-sequence-b.sh\n- script2.sh\n</code></pre>"},{"location":"user/01-core/#pipelines-are-collections","title":"Pipelines are collections","text":"<p><code>Pipelines</code> are an expanded version of a <code>JobCollection</code> and include all of its capabilities (in addition to pipeline-specific abilities). This includes configuration options and the ability to stack other collections within them.</p> <p>Input:</p> TypescriptPython <pre><code>import { Pipeline, Job, JobCollection } from \"../../../src\";\nimport { check } from \"../../comparison\";\ntest(\"test\", () =&gt; {\nconst sequence_a = new JobCollection();\nsequence_a.addChildren({\njobsOrJobCollections: [new Job({ stage: \"job1\", scripts: [\"script1.sh\"] })],\n});\nsequence_a.prependScripts([\"from-sequence.sh\"]);\nconst pipeline = new Pipeline();\npipeline.addChildren({ jobsOrJobCollections: [sequence_a] });\npipeline.addChildren({\njobsOrJobCollections: [new Job({ stage: \"job2\", scripts: [\"script2.sh\"] })],\n});\npipeline.prependScripts([\"from-pipeline.sh\"]);\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef test():\nsequence_a = gcip.Sequence()\nsequence_a.add_children(gcip.Job(stage=\"job1\", script=\"script1.sh\"))\nsequence_a.prepend_scripts(\"from-sequence.sh\")\npipeline = gcip.Pipeline()\npipeline.add_children(sequence_a)\npipeline.add_children(gcip.Job(stage=\"job2\", script=\"script2.sh\"))\npipeline.prepend_scripts(\"from-pipeline.sh\")\nconftest.check(pipeline.render())\n</code></pre> <p>Output:</p> <pre><code>stages:\n- job1\n- job2\njob1:\nstage: job1\nscript:\n- from-pipeline.sh\n- from-sequence.sh\n- script1.sh\njob2:\nstage: job2\nscript:\n- from-pipeline.sh\n- script2.sh\n</code></pre>"},{"location":"user/01-core/#stages-allow-reuse-of-jobs-and-collections","title":"Stages allow reuse of jobs and collections","text":"<p>Suppose you intend to reuse a parameterized job. The following code illustrates an incorrect example:</p> TypescriptPython <pre><code>import { Job, Pipeline } from \"../../../src\";\nexport function jobFor(environment: string): Job {\nreturn new Job({\nstage: \"do_something\",\nscripts: [`./do-something-on.sh ${environment}`],\n});\n}\ntest(\"test\", () =&gt; {\nconst pipeline = new Pipeline();\nfor (const env of [\"development\", \"test\"]) {\npipeline.addChildren({ jobsOrJobCollections: [jobFor(env)] });\n}\nexpect(() =&gt; {\npipeline.render();\n}).toThrowError(/Two jobs have the same name/);\n});\n</code></pre> <pre><code>import pytest\nfrom gcip import Job, Pipeline, JobNameConflictError\ndef job_for(environment: str) -&gt; Job:\nreturn Job(stage=\"do_something\", script=f\"./do-something-on.sh {environment}\")\ndef test():\npipeline = Pipeline()\nfor env in [\"development\", \"test\"]:\npipeline.add_children(job_for(env))\nwith pytest.raises(JobNameConflictError):\npipeline.render()\n</code></pre> <p>When rendering this pipeline, it results in an error.</p> <pre><code>Error: Two jobs have the same name 'do-something' when rendering the pipeline\nPlease fix this by providing a different name and/or stage when adding those jobs to their collections/pipeline.\n</code></pre> <p>The error arises because both jobs were added with the same name to the pipeline, causing the second job to overwrite the first one.</p> <p>To avoid such conflicts, when adding jobs or collections to a collections, you should use the <code>.addChildren()</code> method, which accepts the <code>stage</code> property. You can utilize this property to modify the name of the jobs added. The value of <code>stage</code> will be appended to the jobs' <code>name</code> and <code>stage</code>. However, please note that this modification only applies to the jobs or collections added at that moment and not to the jobs and collections already present within the collection.</p>"},{"location":"user/01-core/#reuse-jobs","title":"Reuse jobs","text":"<p>Input:</p> TypescriptPython <pre><code>import { Pipeline, Job } from \"../../../src\";\nimport { check } from \"../../comparison\";\nexport function jobFor(environment: string): Job {\nreturn new Job({\nstage: \"do_something\",\nscripts: [`./do-something-on.sh ${environment}`],\n});\n}\ntest(\"test\", () =&gt; {\nconst pipeline = new Pipeline();\nfor (const env of [\"development\", \"test\"]) {\npipeline.addChildren({ jobsOrJobCollections: [jobFor(env)], stage: env });\n}\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef job_for(environment: str) -&gt; gcip.Job:\nreturn gcip.Job(stage=\"do_something\", script=f\"./do-something-on.sh {environment}\")\ndef test():\npipeline = gcip.Pipeline()\nfor env in [\"development\", \"test\"]:\npipeline.add_children(job_for(env), stage=env)\nconftest.check(pipeline.render())\n</code></pre> <p>The error occurred because we added both jobs to the collection with different stage values. By doing so, in the output, we correctly populate one job per environment, ensuring that each job is appropriately associated with its respective environment.</p> <p>Output:</p> <pre><code>stages:\n- do_something_development\n- do_something_test\ndevelopment-do-something:\nstage: do_something_development\nscript:\n- ./do-something-on.sh development\ntest-do-something:\nstage: do_something_test\nscript:\n- ./do-something-on.sh test\n</code></pre>"},{"location":"user/01-core/#reuse-collections","title":"Reuse collections","text":"<p>Namespacing significantly enhances the reusability of collections. You can encapsulate an entire GitLab CI pipeline within a collection and then reuse that collection for each environment. By repeating the collection within a loop for all environments, namespacing ensures that all jobs of the collection are populated uniquely for each environment, enabling efficient configuration management and deployment.</p> <p>Input:</p> TypescriptPython <pre><code>import { Pipeline, JobCollection, Job } from \"../../../src\";\nimport { check } from \"../../comparison\";\nexport function environmentPipeline(environment: string): JobCollection {\nconst collection = new JobCollection();\ncollection.addChildren({\njobsOrJobCollections: [\nnew Job({ stage: \"job1\", scripts: [`job-1-on-${environment}`] }),\nnew Job({ stage: \"job2\", scripts: [`job-2-on-${environment}`] }),\n],\n});\nreturn collection;\n}\ntest(\"test\", () =&gt; {\nconst pipeline = new Pipeline();\nfor (const env of [\"development\", \"test\"]) {\npipeline.addChildren({\njobsOrJobCollections: [environmentPipeline(env)],\nstage: env,\n});\n}\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef environment_pipeline(environment: str) -&gt; gcip.Sequence:\nsequence = gcip.Sequence()\nsequence.add_children(\ngcip.Job(stage=\"job1\", script=f\"job-1-on-{environment}\"),\ngcip.Job(stage=\"job2\", script=f\"job-2-on-{environment}\"),\n)\nreturn sequence\ndef test():\npipeline = gcip.Pipeline()\nfor env in [\"development\", \"test\"]:\npipeline.add_children(environment_pipeline(env), stage=env)\nconftest.check(pipeline.render())\n</code></pre> <p>Output:</p> <pre><code>stages:\n- job1_development\n- job2_development\n- job1_test\n- job2_test\ndevelopment-job1:\nstage: job1_development\nscript:\n- job-1-on-development\ndevelopment-job2:\nstage: job2_development\nscript:\n- job-2-on-development\ntest-job1:\nstage: job1_test\nscript:\n- job-1-on-test\ntest-job2:\nstage: job2_test\nscript:\n- job-2-on-test\n</code></pre>"},{"location":"user/01-core/#parallelization-name-stage","title":"Parallelization - name, stage","text":"<p>As evident from the previous examples, all jobs possess a distinct <code>stage</code>, causing them to run within collections. This behavior occurs because the <code>stage</code> property always extends the job's <code>name</code> and <code>stage</code>. This principle applies universally to all <code>stage</code> properties, be it for the constructor of a Job object or the <code>.add_*()</code> methods of a collection.</p> <p>When adding jobs to a collection, whether directly or within another collection, the objective is to merely extend the <code>name</code> of the jobs, leaving their <code>stage</code> unchanged. This approach ensures that jobs with equal stages can run in parallel.</p> <p>To achieve this, you can set identical values for the <code>stage</code> property while providing different values for the <code>name</code> property when creating jobs or adding them to collections. By doing so, the <code>name</code> property will extend only the name of a job without affecting its <code>stage</code>.</p>"},{"location":"user/01-core/#name-property-when-creating-jobs","title":"<code>name</code> property when creating jobs","text":"<p>Input:</p> TypescriptPython <pre><code>import { Job, Pipeline } from \"../../../src\";\nimport { check } from \"../../comparison\";\ntest(\"test\", () =&gt; {\nconst pipeline = new Pipeline();\npipeline.addChildren({\njobsOrJobCollections: [\nnew Job({ name: \"job1\", stage: \"single-stage\", scripts: [\"date\"] }),\nnew Job({ name: \"job2\", stage: \"single-stage\", scripts: [\"date\"] }),\n],\n});\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef test():\npipeline = gcip.Pipeline()\npipeline.add_children(\ngcip.Job(name=\"job1\", stage=\"single-stage\", script=\"date\"),\ngcip.Job(name=\"job2\", stage=\"single-stage\", script=\"date\"),\n)\nconftest.check(pipeline.render())\n</code></pre> <p>Output:</p> <pre><code>stages:\n- single_stage\njob1-single-stage:\nstage: single_stage\nscript:\n- date\njob2-single-stage:\nstage: single_stage\nscript:\n- date\n</code></pre> <p>In this scenario, we have chosen an equal value for the <code>stage</code> parameter, ensuring that both jobs have the same stage. To prevent their <code>name</code> values from being identical (and risking the second job overwriting the first one), we have also provided the <code>name</code> property. The <code>name</code> property's value will be appended to the existing <code>name</code> of the jobs. Consequently, both jobs will run in parallel within the same stage.</p> <p>You might wonder why there is no dedicated <code>stage</code> property. When considering collections, the <code>stage</code> property would extend both the <code>name</code> and <code>stage</code> of a job, while the <code>name</code> property would only extend the <code>name</code> of a job. Extending means appending values to the current <code>name</code> or <code>stage</code> values of a job. However, there's no practical reason to solely extend the <code>stage</code> of a job so that two jobs have distinct stages but unique names. In GitLab CI, a job must have a unique name, so extending just the <code>stage</code> wouldn't serve any purpose. Therefore, the consistent concept of using only the <code>name</code> and <code>stage</code> properties applies to both jobs and collections.</p> <p>As for not omitting the <code>stage</code> property when creating the jobs, it is because of the explanation in the previous paragraph. When creating jobs, we cannot directly set the <code>stage</code> value. Omitting the <code>stage</code> property means leaving it unset, which would default the GitLab CI jobs to the <code>test</code> stage. To define a stage other than <code>test</code>, we used the <code>stage</code> property. Yes, this implies that the job's <code>name</code> will include the value of the <code>stage</code>. However, this design decision clarifies the concept of <code>name</code> and <code>stage</code> more effectively than providing a <code>stage</code> property for jobs, especially when collections lack such a (superfluous) <code>stage</code> property.</p> <p>No worries! Here's a simple guide to keep in mind when creating Jobs:</p> <ol> <li>For distinct jobs that will run in separate stages within a collection, set different values only for the <code>stage</code> property.</li> <li>For distinct jobs that will run in parallel with equal stages, set different values only for the <code>name</code> property.</li> <li>For distinct jobs that will run in parallel with equal stages and a defined stage name, set different values for the <code>name</code> properties but equal values for the <code>stage</code> properties.</li> <li>Setting different values for both properties is not advisable and will result in the first scenario of distinct jobs running in separate stages within a collection.</li> </ol>"},{"location":"user/01-core/#name-parameter-when-adding-jobs-and-collections-to-collections","title":"<code>name</code> parameter when adding jobs (and collections) to collections","text":"<p>Let's consider the collection example from the chapter Stages allow reuse of jobs and collections. Instead of using the <code>stage</code> parameter when adding the collection multiple times to the pipeline, we will now utilize the <code>name</code> parameter.</p> <p>Input:</p> TypescriptPython <pre><code>import { Job, JobCollection, Pipeline } from \"../../../src\";\nimport { check } from \"../../comparison\";\nexport function environmentPipeline(environment: string) {\nconst collection = new JobCollection();\ncollection.addChildren({\njobsOrJobCollections: [\nnew Job({ stage: \"job1\", scripts: [`job-1-on-${environment}`] }),\nnew Job({ stage: \"job2\", scripts: [`job-2-on-${environment}`] }),\n],\n});\nreturn collection;\n}\ntest(\"test\", () =&gt; {\nconst pipeline = new Pipeline();\nfor (const env of [\"development\", \"test\"]) {\npipeline.addChildren({\njobsOrJobCollections: [environmentPipeline(env)],\nname: env,\n});\n}\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef environment_pipeline(environment: str) -&gt; gcip.Sequence:\nsequence = gcip.Sequence()\nsequence.add_children(\ngcip.Job(stage=\"job1\", script=f\"job-1-on-{environment}\"),\ngcip.Job(stage=\"job2\", script=f\"job-2-on-{environment}\"),\n)\nreturn sequence\ndef test():\npipeline = gcip.Pipeline()\nfor env in [\"development\", \"test\"]:\npipeline.add_children(environment_pipeline(env), name=env)\nconftest.check(pipeline.render())\n</code></pre> <p>Now the environments run in parallel, because just the job names are populated per environment but not the stage names.</p> <p>Output:</p> <pre><code>stages:\n- job1\n- job2\ndevelopment-job1:\nstage: job1\nscript:\n- job-1-on-development\ndevelopment-job2:\nstage: job2\nscript:\n- job-2-on-development\ntest-job1:\nstage: job1\nscript:\n- job-1-on-test\ntest-job2:\nstage: job2\nscript:\n- job-2-on-test\n</code></pre> <p>You can also combine the usage of <code>stage</code> and <code>name</code> when adding jobs. This approach is particularly useful when dealing with a large number of jobs, where some groups of jobs should run sequentially while jobs within each group should run in parallel. Here's an example to illustrate this scenario:</p> <p>Input:</p> TypescriptPython <pre><code>import { Job, Pipeline } from \"../../../src\";\nimport { check } from \"../../comparison\";\nexport function jobFor(service: string): Job {\nreturn new Job({\nstage: \"update_service\",\nscripts: [`./update-service.sh ${service}`],\n});\n}\ntest(\"test\", () =&gt; {\nconst pipeline = new Pipeline();\nfor (const env of [\"development\", \"test\"]) {\nfor (const service of [\"service1\", \"service2\"]) {\npipeline.addChildren({\njobsOrJobCollections: [jobFor(`${service}_${env}`)],\nstage: env,\nname: service,\n});\n}\n}\ncheck(pipeline.render(), expect);\n});\n</code></pre> <pre><code>import gcip\nfrom tests import conftest\ndef job_for(service: str) -&gt; gcip.Job:\nreturn gcip.Job(stage=\"update_service\", script=f\"./update-service.sh {service}\")\ndef test():\npipeline = gcip.Pipeline()\nfor env in [\"development\", \"test\"]:\nfor service in [\"service1\", \"service2\"]:\npipeline.add_children(job_for(f\"{service}_{env}\"), stage=env, name=service)\nconftest.check(pipeline.render())\n</code></pre> <p>The output shows that two services are being updated in parallel but within consecutive stages.</p> <p>Output:</p> <pre><code>stages:\n- update_service_development\n- update_service_test\nservice1-development-update-service:\nstage: update_service_development\nscript:\n- ./update-service.sh service1_development\nservice2-development-update-service:\nstage: update_service_development\nscript:\n- ./update-service.sh service2_development\nservice1-test-update-service:\nstage: update_service_test\nscript:\n- ./update-service.sh service1_test\nservice2-test-update-service:\nstage: update_service_test\nscript:\n- ./update-service.sh service2_test\n</code></pre>"}]}